#+TITLE: Emacs configuration
#+AUTHOR: Alain M. Lafon
#+EMAIL: alain@200ok.ch


This repository contains my Emacs configuration. It is written and
documented in literate programming style.

* Installation

*Initial*

Emacs configuration is usually done in the home directory in the
=.emacs.d= folder. This holds true for Unix and Linux systems. For
Windows, look it up [[https://www.gnu.org/software/emacs/manual/html_node/efaq-w32/Location-of-init-file.html][here]].

=git clone git@github.com:munen/emacs.d.git ~/.emacs.d=

*Dependencies*

Emacs dependencies/libraries are managed via the internal [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html#Packages][package
management system]]. To initially install packages, open
=~/.emacs.d/init.el=, refresh your package list with =M-x
package-refresh-contents= and install everything using =M-x
eval-buffer=.

* Dependency management

** Define package repositories(archives)

#+BEGIN_SRC emacs-lisp
  (require 'package)

  (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                           ;; INSECURE ("marmalade" . "https://marmalade-repo.org/packages/")
                           ("melpa" . "https://melpa.org/packages/")))
#+END_SRC

** Define packages that are to be installed

List all used third-party packages. Most will be configured further
down in this file, some are used with the default configuration.

#+BEGIN_SRC emacs-lisp

  (defvar my-packages '(use-package
                        ag
                        atomic-chrome
                        beacon
                        browse-kill-ring
                        flycheck
                        auto-complete
                        web-mode
                        clojure-mode
                        parinfer
                        elfeed
                        elfeed-goodies
                        clj-refactor
                        cider
                        exec-path-from-shell
                        ac-cider
                        js2-mode
                        js-comint
                        js2-refactor
                        rainbow-mode
                        synosaurus
                        ini-mode
                        ac-js2
                        flycheck-flow
                        comment-tags
                        sass-mode
                        yaml-mode
                        pdf-tools
                        ivy counsel swiper
                        tern
                        tern-auto-complete
                        coffee-mode
                        projectile
                        markdown-mode
                        enh-ruby-mode
                        robe
                        evil-mc
                        evil-escape
                        ledger-mode
                        evil
                        evil-leader
                        evil-surround
                        evil-numbers
                        impatient-mode
                        restclient
                        magit
                        darktooth-theme
                        which-key
                        writeroom-mode
                        writegood-mode
                        zenburn-theme))
#+END_SRC

** Install packages

#+BEGIN_SRC emacs-lisp
  (dolist (p my-packages)
    (unless (package-installed-p p)
      (package-refresh-contents)
      (package-install p))
    (add-to-list 'package-selected-packages p))
#+END_SRC

* Default Settings
This section contains settings for built-in Emacs features.

** Gargabe Collection

Allow 20MB of memory (instead of 0.76MB) before calling garbage
collection. This means GC runs less often, which speeds up some
operations.

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 20000000)
#+END_SRC

** Do not create backup files
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
#+END_SRC

** Auto-Save in =/tmp=

Store backups and auto-saved files in =TEMPORARY-FILE-DIRECTORY= (which
defaults to /tmp on Unix), instead of in the same directory as the
file.

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t)))
#+END_SRC

** Always follow symlinks
   When opening a file, always follow symlinks.

#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks t)
#+END_SRC

** Sentences have one space after a period
Don't assume that sentences should have two spaces after
periods.

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

** Confirm before closing Emacs
#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC

** =dired-mode=

Ability to use =a= to visit a new directory or file in =dired= instead
of using =RET=. =RET= works just fine, but it will create a new buffer
for /every/ interaction whereas =a= reuses the current buffer.

#+BEGIN_SRC emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

Human readable units

#+BEGIN_SRC emacs-lisp
  (setq-default dired-listing-switches "-alh")
#+END_SRC

** Ask =y/n= instead of =yes/no=
   This is a favorable shorthand.
#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Auto revert files on change
When something changes a file, automatically refresh the
buffer containing that file so they can't get out of sync.

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC
** Shortcut for changing font-size
#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "C-1") 'text-scale-increase)
  (define-key global-map (kbd "C-0") 'text-scale-decrease)
#+END_SRC
** Disable startup message

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
  (setq inhibit-startup-message t)
#+END_SRC

** Display the current time
#+BEGIN_SRC emacs-lisp
  (display-time-mode t)
#+END_SRC

** Do not display GUI Toolbar

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode 0)
#+END_SRC

** Automatic Line Breaks
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC

** Enable Narrow To Region

Enable narrow-to-region (C-x n n / C-x n w). This is disabled by
default to not confuse beginners.

#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-region 'disabled nil)
#+END_SRC

** Disable scroll bars
#+BEGIN_SRC emacs-lisp
(scroll-bar-mode -1)
#+END_SRC
** Remember the cursor position of files when reopening them
#+BEGIN_SRC emacs-lisp
  (setq save-place-file "~/.emacs.d/saveplace")
  (setq-default save-place t)
  (require 'saveplace)
#+END_SRC
** Set $MANPATH, $PATH and exec-path from shell even when started from GUI helpers like =dmenu= or =Spotlight=

#+BEGIN_SRC emacs-lisp

    (exec-path-from-shell-initialize)

#+END_SRC
** =windmove=

Windmove is built into Emacs. It lets you move point from window to
window using Shift and the arrow keys. This is easier to type than
‘C-x o’ when there are multiple windows open.

#+BEGIN_SRC emacs-lisp

(when (fboundp 'windmove-default-keybindings)
  (windmove-default-keybindings))

#+END_SRC

** =winner-mode=

Allows to 'undo' (and 'redo') changes in the window configuration with
the key commands ‘C-c left’ and ‘C-c right’.

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'winner-mode)
    (winner-mode 1))
#+END_SRC

Getting from many windows to one window is easy: 'C-x 1' will do it.
But getting back to a delicate WindowConfiguration is difficult. This
is where Winner Mode comes in: With it, going back to a previous
session is easy.
** Bell
   Do not ring the system bell, but show a visible feedback.

#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC
** AngeFtp
Try to use passive mode for FTP.

Note: Some firewalls might not allow standard active mode. However:
Some FTP Servers might not allow passive mode. So if there's problems
when connecting to an FTP, try to revert to active mode.
#+BEGIN_SRC emacs-lisp
(setq ange-ftp-try-passive-mode t)
#+END_SRC
** eww
   When entering eww, use cursors to scroll without changing point.
#+BEGIN_SRC emacs-lisp
  (add-hook 'eww-mode-hook 'scroll-lock-mode)
#+END_SRC
** Custom-File
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom-settings.el")
(load custom-file t)
#+END_SRC
* General
This section contains settings for non-built-in Emacs features that
are generally applicable to different kinds of modes.
** =beacon-mode=
https://github.com/Malabarba/beacon

Whenever the window scrolls a light will shine on top of your cursor so you know where it is.
#+BEGIN_SRC emacs-lisp
(beacon-mode 1)
#+END_SRC
** =browse-kill-ring=
Ever wish you could just look through everything you've killed
recently to find out if you killed that piece of text that you think
you killed (or yanked), but you're not quite sure? If so, then
browse-kill-ring is the Emacs extension for you.

#+BEGIN_SRC emacs-lisp
  (require 'browse-kill-ring)
  (setq browse-kill-ring-highlight-inserted-item t
        browse-kill-ring-highlight-current-entry nil
        browse-kill-ring-show-preview t)
  (define-key browse-kill-ring-mode-map (kbd "j") 'browse-kill-ring-forward)
  (define-key browse-kill-ring-mode-map (kbd "k") 'browse-kill-ring-previous)
#+END_SRC

* =evil-mode=
Evil is an extensible Vim layer for Emacs.

This combines the best of both worlds: VIM being a great text-editor
with modal editing through semantic commands and Emacs being a LISP
REPL.
** Enable Evil
#+BEGIN_SRC emacs-lisp
  (evil-mode t)
  ;; Enable "M-x" in evil mode
  (global-set-key (kbd "M-x") 'execute-extended-command)
#+END_SRC

** Leader Mode Config

#+BEGIN_SRC emacs-lisp
  (global-evil-leader-mode)
  (evil-leader/set-leader ",")
  (evil-leader/set-key
    "w" 'basic-save-buffer
    "s" 'flyspell-buffer
    "b" 'evil-buffer
    "q" 'evil-quit)
#+END_SRC

** Evil Surround, emulating tpope's =surround.vim=

#+BEGIN_SRC emacs-lisp
  (require 'evil-surround)
  (global-evil-surround-mode 1)
#+END_SRC

** Multiple Cursors
https://github.com/gabesoft/evil-mc

=evil-mc= provides multiple cursors functionality for Emacs when used
with =evil-mode=.

=C-n / C-p= are used for creating cursors, and =M-n / M-p= are used
for cycling through cursors. The commands that create cursors wrap
around; but, the ones that cycle them do not. To skip creating a
cursor forward use =C-t= or =grn= and backward =grp=. Finally use
=gru= to remove all cursors.

*** Enable =evil-mc= for all buffers

#+BEGIN_SRC emacs-lisp
(global-evil-mc-mode  1)
#+END_SRC

** Fast switching between buffers
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "{") 'evil-next-buffer)
  (define-key evil-normal-state-map (kbd "}") 'evil-prev-buffer)
#+END_SRC

** Increment / Decrement numbers

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-=") 'evil-numbers/inc-at-pt)
  (global-set-key (kbd "C--") 'evil-numbers/dec-at-pt)
  (define-key evil-normal-state-map (kbd "C-=") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "C--") 'evil-numbers/dec-at-pt)
#+END_SRC

** Use =j/k= for browsing wrapped lines
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
  (define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line)
#+END_SRC

** Paste in Visual Mode

#+BEGIN_SRC emacs-lisp
  (define-key evil-insert-state-map (kbd "C-v") 'evil-visual-paste)

#+END_SRC

** Disable =evil-mode= for some modes
   Since Emacs is a multi-purpose LISP REPL, there are many modes that
   are not primarily (or not at all) centered about text-manipulation.
   For those, it is reasonable to disable =evil-mode=, because it will
   bring nothing to the table, but might just shadow some keyboard
   shortcuts.
#+BEGIN_SRC emacs-lisp
  (mapc (lambda (mode)
          (evil-set-initial-state mode 'emacs)) '(elfeed-show-mode
                                                  elfeed-search-mode
                                                  dired-mode
                                                  image-dired-mode
                                                  image-dired-thumbnail-mode
                                                  eww-mode))
#+END_SRC
** Unbind M-. and M- in =evil-mode=
=M-.= and =M-,= are popular keybindings for "jump to definition" and
"back". =evil-mode= by default binds those to rather rarely used
functions =evil-repeat-pop-next= and =xref-pop-marker-stack=, for some reason.

#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "M-.") nil)
  (define-key evil-normal-state-map (kbd "M-,") nil)
#+END_SRC
** =evil-escape=
https://github.com/syl20bnr/evil-escape

Escape from insert state and everything else.

#+BEGIN_SRC emacs-lisp
  (setq-default evil-escape-delay 0.2)
  (setq-default evil-escape-key-sequence "jk")
  (evil-escape-mode)
#+END_SRC

This results in the same feature-set like this vim keybinding:
#+BEGIN_SRC vim
"Remap ESC to jk
:imap jk <esc>
#+END_SRC

* Search

Replace i-search-(forward|backward) with their respective regexp
capable counterparts

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)

#+END_SRC

* Which Key
  =which-key= displays available keybindings in a popup.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'which-key-mode)
  (add-hook 'cider-mode-hook 'which-key-mode)
#+END_SRC

* Programming
** General
*** Auto Complete
https://github.com/auto-complete/auto-complete

Basic Configuration
#+BEGIN_SRC emacs-lisp
  (ac-config-default)
#+END_SRC
*** Tabs
Set tab width to 2 for all buffers

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 2)
#+END_SRC

Use 2 spaces instead of a tab.

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 2 indent-tabs-mode nil)
#+END_SRC

Indentation cannot insert tabs.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

Use 2 spaces instead of tabs for programming languages.

#+BEGIN_SRC emacs-lisp
  (setq js-indent-level 2)

  (setq coffee-tab-width 2)

  (setq python-indent 2)

  (setq css-indent-offset 2)

  (add-hook 'sh-mode-hook
            (lambda ()
              (setq sh-basic-offset 2
                    sh-indentation 2)))

  (setq web-mode-markup-indent-offset 2)
#+END_SRC

*** Syntax Checking

http://www.flycheck.org/

Enable global on the fly syntax checking through =flycheck=.

#+BEGIN_SRC emacs-lisp

  (add-hook 'after-init-hook #'global-flycheck-mode)

#+END_SRC
*** Manage TODO/FIXME/XXX comments

https://github.com/vincekd/comment-tags

=comment-tags= highlights and lists comment tags such as 'TODO', 'FIXME', 'XXX'.

Commands (prefixed by =C-c t=):

    - =b= to list tags in current buffer (comment-tags-list-tags-buffer).
    - =a= to list tags in all buffers (comment-tags-list-tags-buffers).
    - =s= to jump to tag in current buffer by a word or phrase using reading-completion (comment-tags-find-tags-buffer).
    - =n= to jump to next tag from point (comment-tags-next-tag).
    - =p= to jump to previous tag from point (comment-tags-previous-tag).

#+BEGIN_SRC emacs-lisp
  (setq comment-tags-keymap-prefix (kbd "C-c t"))
  (with-eval-after-load "comment-tags"
    (setq comment-tags-keyword-faces
          `(("TODO" . ,(list :weight 'bold :foreground "#DF5427"))
            ("FIXME" . ,(list :weight 'bold :foreground "#DF5427"))
            ("BUG" . ,(list :weight 'bold :foreground "#DF5427"))
            ("HACK" . ,(list :weight 'bold :foreground "#DF5427"))
            ("KLUDGE" . ,(list :weight 'bold :foreground "#DF5427"))
            ("XXX" . ,(list :weight 'bold :foreground "#DF5427"))
            ("INFO" . ,(list :weight 'bold :foreground "#1FDA9A"))
            ("DONE" . ,(list :weight 'bold :foreground "#1FDA9A"))))
    (setq comment-tags-comment-start-only t
          comment-tags-require-colon t
          comment-tags-case-sensitive t
          comment-tags-show-faces t
          comment-tags-lighter nil))
  (add-hook 'prog-mode-hook 'comment-tags-mode)
#+END_SRC

*** Auto-indent with the Return key

#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC

*** Highlight matching parenthesis

#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
#+END_SRC

*** Delete trailing whitespace

Delete trailing whitespace in all modes. _Except_ when editing
Markdown, because it uses [[http://daringfireball.net/projects/markdown/syntax#p][two trailing blanks]] as a signal to create a
line break.

#+BEGIN_SRC emacs-lisp
    (add-hook 'before-save-hook '(lambda()
                                  (when (not (or (derived-mode-p 'markdown-mode)
                                                 (derived-mode-p 'org-mode))
                                    (delete-trailing-whitespace)))))

(use-package whitespace
  :init
  (dolist (hook '(prog-mode-hook text-mode-hook))
    (add-hook hook #'whitespace-mode))
  (add-hook 'before-save-hook #'whitespace-cleanup)
  :config
  (setq whitespace-line-column 80) ;; limit line length
  (setq whitespace-style '(face tabs empty trailing lines-tail)))
#+END_SRC

*** Code Folding

Enable code folding for programming modes.

- =zc=: Fold
- =za=: Unfold
- =zR=: Unfold everything

#+BEGIN_SRC emacs-lisp

(add-hook 'prog-mode-hook #'hs-minor-mode)

#+END_SRC

** Ruby

*** Standard linters

For syntax checking to work, installing the command-line linter tools
[[https://gitlab.com/yorickpeterse/ruby-lint][ruby-lint]] and [[https://eslint.org/][eslint]] are a premise:

#+BEGIN_SRC shell
gem install rubocop ruby-lint
npm install -g eslint
#+END_SRC

*** Configuration

#+BEGIN_SRC emacs-lisp
  (setq ruby-indent-level 2)
  (add-to-list 'auto-mode-alist '("\\.scss?\\'" . scss-mode))

  (add-to-list 'auto-mode-alist '("\\.rb?\\'" . enh-ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.rake?\\'" . enh-ruby-mode))
  (add-hook 'enh-ruby-mode-hook 'linum-mode)
#+END_SRC

*** =robe-mode=

https://github.com/dgutov/robe

Code navigation, documentation lookup and completion for Ruby

#+BEGIN_SRC emacs-lisp
  (add-hook 'enh-ruby-mode-hook 'robe-mode)
  (add-hook 'robe-mode-hook 'ac-robe-setup)
  (add-to-list 'auto-mode-alist '("\\.erb?\\'" . robe-mode))
#+END_SRC

Start =robe-mode= with =M-x robe-start=.

Shortcuts:

- =C-c C-d= Lookup documentation
- =M-.= Jump to definition
- =TAB= Auto-completion through =auto-complete-mode=

**** =auto-complete= for =robe-mode=

#+BEGIN_SRC emacs-lisp

(add-hook 'enh-ruby-mode-hook 'auto-complete-mode)

#+END_SRC

** Clojure
*** Cider

https://github.com/clojure-emacs/cider

Cider is short for The "Clojure Interactive Development Environment
that Rocks for Emacs". For good reasons, it is the [[http://blog.cognitect.com/blog/2017/1/31/clojure-2018-results][most popular IDE]]
for developing Clojure.

-  =M-x cider-jack-in= To start REPL
-  =C-c C-k= Evaluate current buffer
-  =C-c M-n= Change ns in cider-nrepl to current ns
-  =C-c C-d C-d= Display documentation for the symbol under point
-  =C-c C-d C-a= Apropos search for arbitrary text across function names
   and documentation

**** CIDER REPL Key Bindings

- =C-↑, C-↓= Cycle through REPL history.
- More Cider shortcuts [[https://github.com/clojure-emacs/cider#cider-mode][here]].

**** Dependencies

Create a =~/.lein/profiles.clj= file with:

#+BEGIN_SRC clojure
    {:user {:plugins [[cider/cider-nrepl "0.13.0-SNAPSHOT"]
                      [refactor-nrepl "2.2.0"]]
            :dependencies [[org.clojure/tools.nrepl "0.2.12"]]}}
#+END_SRC

**** Emacs configuration

Setup Cider with =auto-complete=.

#+BEGIN_SRC emacs-lisp

  (require 'ac-cider)
  ;;(setq ac-quick-help-delay 0.5)
  (add-hook 'cider-mode-hook 'ac-flyspell-workaround)
  (add-hook 'cider-mode-hook 'ac-cider-setup)
  (add-hook 'cider-repl-mode-hook 'ac-cider-setup)
  (eval-after-load "auto-complete"
    '(progn
       (add-to-list 'ac-modes 'cider-mode)
       (add-to-list 'ac-modes 'cider-repl-mode)))

#+END_SRC

When connecting to a repl, don't pop to the new repl buffer.

#+BEGIN_SRC emacs-lisp
(setq cider-repl-pop-to-buffer-on-connect nil)
#+END_SRC

*** =clj-refactor=.

https://github.com/clojure-emacs/clj-refactor.el/

A collection of Clojure refactoring functions for Emacs.

#+BEGIN_SRC emacs-lisp
  (require 'clj-refactor)
  (add-hook 'clojure-mode-hook
            (lambda ()
              (clj-refactor-mode 1)
              (setq cljr-warn-on-eval nil)
              (yas-minor-mode 1) ; for adding require/use/import statements
              ;; This choice of keybinding leaves cider-macroexpand-1 unbound
              (cljr-add-keybindings-with-prefix "C-c C-m")))
#+END_SRC

=clj-refactor= enables refactorings like extracting functions (=C-c
C-m ef=). Find the list of available refactorings [[https://github.com/clojure-emacs/clj-refactor.el/wiki][here]].

** JavaScript

*** =js2-mode= and =tern=

JavaScript is improved with =js2-mode= as well as
[[http://ternjs.net/][Tern]].

Tern is a stand-alone code-analysis engine for JavaScript used for:

- Auto completion on variables and properties
- Function argument hints
- Querying the type of an expression
- Finding the definition of something
- Automatic refactoring

Tern is installed as an NPM package: =npm install -g tern=.

To enable Tern in emacs, the =tern= and =tern-auto-complete=
packages are installed.

For completion to work in a Node.js project, a =.tern-project= file like
this is required:

#+BEGIN_EXAMPLE
    {"plugins": {"node": {}}}
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    {"libs": ["browser", "jquery"]}
#+END_EXAMPLE

If no project file is found, it’ll fall back to a default
configuration. You can change this default configuration by putting a
=.tern-config= file, with the same format as =.tern-project=, in your home
directory.

My =~/.tern-config= file looks like this:

#+BEGIN_SRC
{
  "libs": [
    "browser"
  ],
  "plugins": {
    "es_modules": {},
    "node": {}
  }
}
#+END_SRC

[[http://ternjs.net/doc/manual.html#configuration][Here]] is more documentation on how to configure a Tern project.

Tern shortcuts:

- =M-.= Jump to the definition of the thing under the cursor.
- =M-,= Brings you back to last place you were when you pressed M-..
- =C-c C-r= Rename the variable under the cursor.
- =C-c C-c= Find the type of the thing under the cursor.
- =C-c C-d= Find docs of the thing under the cursor. Press again to
  open the associated URL (if any).

**** Configuration

#+BEGIN_SRC emacs-lisp

  (add-hook 'js-mode-hook (lambda () (tern-mode t)))
  (eval-after-load 'tern
     '(progn
        (require 'tern-auto-complete)
        (tern-ac-setup)))

#+END_SRC


*** =js2-refactor=
https://github.com/magnars/js2-refactor.el

A JavaScript refactoring library for Emacs.

#+BEGIN_SRC emacs-lisp
(add-hook 'js2-mode-hook #'js2-refactor-mode)
(js2r-add-keybindings-with-prefix "C-c C-m")
#+END_SRC
*** =js-comint=
https://github.com/redguardtoo/js-comint

Run a JavaScript interpreter in an inferior process window.
**** Enable
#+BEGIN_SRC emacs-lisp
(require 'js-comint)
#+END_SRC
**** Configure
#+BEGIN_SRC emacs-lisp
(add-hook 'js2-mode-hook
          (lambda ()
            (local-set-key (kbd "C-x C-e") 'js-send-last-sexp)
            (local-set-key (kbd "C-M-x") 'js-send-last-sexp-and-go)
            (local-set-key (kbd "C-c b") 'js-send-buffer)
            (local-set-key (kbd "C-c C-b") 'js-send-buffer-and-go)
            (local-set-key (kbd "C-c l") 'js-load-file-and-go)))
#+END_SRC
*** =flow=
https://github.com/flowtype/flow-for-emacs/

An emacs plugin for Flow, a static typechecker for JavaScript.

- Shows errors found by typechecking JavaScript code with Flow.
- Provides a bunch of common IDE features powered by Flow to aid reading and writing JavaScript code.
#+BEGIN_SRC elisp
(load-file "~/.emacs.d/flow-for-emacs/flow.el")
#+END_SRC

*** =flycheck-flow=

[[https://flow.org/][Flow]] is a static type checker for JavaScript.

**** Type Inference

Flow uses type inference to find bugs even without type annotations.
It precisely tracks the types of variables as they flow through your
program.

**** Idiomatic JS

Flow is designed for JavaScript programmers. It understands common
JavaScript idioms and very dynamic code.

**** Realtime Feedback

Flow incrementally rechecks your changes as you work, preserving the
fast feedback cycle of developing plain JavaScript.

**** Configuration

#+BEGIN_SRC elisp
(require 'flycheck-flow)
(add-hook 'javascript-mode-hook 'flycheck-mode)
#+END_SRC

*** General JavaScript configuration

#+BEGIN_SRC emacs-lisp

  (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))

  (add-hook 'js-mode-hook 'js2-minor-mode)
  (setq js2-highlight-level 3)
  (setq js-indent-level 2)
  ;; Semicolons are optional in JS, do not warn about them missing
  (setq js2-strict-missing-semi-warning nil)

#+END_SRC

** Web
*** rainbow-mode
=rainbow-mode= is a minor mode for Emacs which displays strings
representing colors with the color they represent as background.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'rainbow-mode)
#+END_SRC
*** Impatient Mode

https://github.com/netguy204/imp.el

Live JavaScript Coding Emacs/Browser: See your changes in the browser as you type

**** Usage

Enable the web server provided by simple-httpd: =M-x httpd-start=

Publish buffers by enabling the minor mode impatient-mode: =M-x impatient-mode=

And then point your browser to http://localhost:8080/imp/, select a
buffer, and watch your changes appear as you type!


*** Process JSON

[[https://stedolan.github.io/jq/][jq]] is a lightweight and flexible command-line JSON processor.

Thanks to [[https://github.com/branch14/emacs.d][@branch14]] of 200ok fame for the function!

#+BEGIN_SRC emacs-lisp
(defun jq-json ()
  (interactive)
  (save-excursion
    (shell-command-on-region
     (point-min)
     (point-max)
     (read-string "Command: " "jq -M '.'") t t)))
#+END_SRC

*** web-mode

http://web-mode.org/

web-mode.el is an autonomous major-mode for editing web templates.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  ;; Ruby Templates
  (add-to-list 'auto-mode-alist '("\\.erb?\\'" . web-mode))
  ;; Handlebars
  (add-to-list 'auto-mode-alist '("\\.hbs?\\'" . web-mode))
  ;; JSON
  (add-to-list 'auto-mode-alist '("\\.json?\\'" . web-mode))

  (setq web-mode-enable-current-element-highlight t)
  (setq web-mode-ac-sources-alist
    '(("html" . (ac-source-words-in-buffer ac-source-abbrev))))
#+END_SRC

** p_slides

[[https://github.com/munen/p_slides][p_slides]] is a static files only, dead simple way, to create semantic
slides. The slide content is markdown, embedded in a HTML file. When
opening a =presentation.html= file, enable =markdown-mode=.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("presentation.html" . markdown-mode))
  (add-hook 'markdown-mode-hook 'flyspell-mode)
#+END_SRC

** Auto Reload Web Sites

Introducing a custom =browser-reloading-mode=. It's a quick
implementation and not a real derived mode.

When enabling =browser-reloading-mode= for a specific buffer, whenever
this buffer is saved, a command-line utility =reload_chromium.sh= is
called. This in turn is a wrapper around =xdotool= with which a
reloading of the Chromium browser is triggered.

This is handy when working in a web environment that doesn't natively
support hot-reloading (static web pages, for instance) and the page
has too much (dynamic) content to be displayed properly in
=impatient-mode=. I'm using it for example when working on a [[https://github.com/munen/p_slides][p_slides]]
slide deck.

#+BEGIN_SRC emacs-lisp
  (defun reload-chromium ()
    (when enable-browser-reloading
      (shell-command-to-string "reload_chromium.sh")))

  (defun browser-reloading-mode ()
    "Finds the open chromium session and reloads the tab"
    (interactive)
    ;; When set, disable the local binding and therefore disable the mode
    (if enable-browser-reloading
        (setq enable-browser-reloading nil)
      ;; Otherwise create a local var and set it to True
      (progn
        (make-local-variable 'enable-browser-reloading)
        (setq enable-browser-reloading t))))

  ;; By default, disable the guard against using `reload-chromium`
  (setq enable-browser-reloading nil)
  (add-hook 'after-save-hook #'reload-chromium)
#+END_SRC

** yaml

#+BEGIN_SRC emacs-lisp
  (require 'yaml-mode)
  (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
#+END_SRC

** Markdown
#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook 'auto-fill-mode)

#+END_SRC

** Magit

Magit is an interface to the version control system Git.

*** Configuration

Create shortcut for =Magit=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x g") 'magit-status)
#+END_SRC

Always sign commits with GPG

#+BEGIN_SRC emacs-lisp
 (setq magit-commit-arguments (quote ("--gpg-sign=alain@200ok.ch")))
#+END_SRC

**** Start the commit buffer in evil normal mode

#+BEGIN_SRC emacs-lisp
  (add-hook 'with-editor-mode-hook 'evil-normal-state)
#+END_SRC

** Projectile

https://github.com/bbatsov/projectile

Projectile is a project interaction library. For instance -
finding project files (=C-c p f=)  or jumping to a new project (=C-c p
p=).

*** Configuration

Enable Projectile globally

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode)
#+END_SRC

* org-mode

Outline-based notes management and organizer. It is an outline-mode
for keeping track of everything.

** Plain Lists
Allow ‘a.’, ‘A.’, ‘a)’ and ‘A) as list elements:

#+BEGIN_SRC emacs-lisp

(setq org-list-allow-alphabetical t)

#+END_SRC

** General configuration

#+BEGIN_SRC emacs-lisp

  (require 'org)

  ; languages for org-babel support
  (org-babel-do-load-languages
   'org-babel-load-languages
   '(
     (shell . t)
     (js . t)
     (ruby . t)
     ))

  (add-hook 'org-mode-hook 'auto-fill-mode)
  (add-hook 'org-mode-hook 'flyspell-mode)

  (setq org-directory "~/switchdrive/org/")

  (defun set-org-agenda-files ()
    "Set different org-files to be used in `org-agenda`."
    (setq org-agenda-files (list (concat org-directory "things.org")
                                 (concat org-directory "refile-beorg.org")
                                 (concat org-directory "inbox.org")
                                 (concat "~/Dropbox/ZHAW/web3-unterlagen/README.org")
                                 (concat "~/Dropbox/ZHAW/weng-unterlagen/README.org")
                                 (concat "~/src/200ok/crowdfunding/TODO.org")
                                 (concat org-directory "reference.org"))))

  (set-org-agenda-files)

  (global-set-key "\C-cl" 'org-store-link)

  (defun things ()
    "Open main 'org-mode' file and start 'org-agenda' for today."
    (interactive)
    (find-file (concat org-directory "things.org"))
    (set-org-agenda-files)
    (org-agenda-list)
    (org-agenda-day-view)
    (shrink-window-if-larger-than-buffer)
    (other-window 1))

  (evil-leader/set-key
    "a" 'org-archive-subtree-default)

  ;; Allow =pdflatex= to use shell-commands
  ;; This will allow it to use =pygments= as syntax highlighter for exports to PDF
  (setq org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

  ;; Include =minted= package for LaTeX exports
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-listings 'minted)


#+END_SRC

** KOMA Script export

#+BEGIN_SRC emacs-lisp
(require 'ox-latex)
(add-to-list 'org-latex-classes
             '("scrartcl"
               "\\documentclass{scrartcl}"
               ("\\section{%s}" . "\\section*{%s}")))
#+END_SRC
** Tufte org-mode export

#+BEGIN_SRC emacs-lisp

(require 'ox-latex)
(add-to-list 'org-latex-classes
	     '("tuftehandout"
	       "\\documentclass{tufte-handout}
\\usepackage{color}
\\usepackage{amssymb}
\\usepackage{amsmath}
\\usepackage{gensymb}
\\usepackage{nicefrac}
\\usepackage{units}"
	       ("\\section{%s}" . "\\section*{%s}")
	       ("\\subsection{%s}" . "\\subsection*{%s}")
	       ("\\paragraph{%s}" . "\\paragraph*{%s}")
	       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

#+END_SRC

** Capture Templates
Set up capture templates for:

- Todos which land in =inbox.org=
- Code Snippets which land in =snippets.org=
- Shopping Items which get appended to the Shopping List in =things.org=
- Media Entries (watch/read later items) that land in =media.org=

Org Capture Templates are explained [[http://orgmode.org/manual/Capture-templates.html][here]], Org Template expansion [[http://orgmode.org/manual/Template-expansion.html#Template-expansion][here.]]

#+BEGIN_SRC emacs-lisp
  ;; Set org-capture inbox
  (setq org-default-notes-file (concat org-directory "inbox.org"))
  (define-key global-map "\C-cc" 'org-capture)

  (setq org-capture-templates
        '(("t" "Todo" entry (file+headline (concat org-directory "inbox.org") "Tasks")
           "* TODO %?\n  %U\n  %i\n  %a")
          ("s" "Code Snippet" entry (file+headline "~/src/200ok/knowledge/README.org" "Snippets")
           ;; Prompt for tag and language
           "* %?\t%^g\n#+BEGIN_SRC %^{language}\n%i\n#+END_SRC")
          ("S" "Shopping Item" entry
           (file+headline (concat org-directory "things.org") "Shopping")
           ;; Prompt for tag and language
           "* TODO %?\n  %U\n")
          ("m" "Media" entry
           (file+datetree (concat org-directory "media.org"))
           "* %?\nURL: \nEntered on %U\n")))

#+END_SRC

** Pomodoro

A leightweight implementation of the Pomodoro Technique is implemented
through customizing orgmode. For every Clock that is started (=C-c C-x
C-i=) an automatic Timer is scheduled to 25min. After these 25min are
up, a "Time to take a break!" message is played and a pop-up
notification is shown.

The timer is not automatically stopped on clocking out, because clocking
in should still work on new tasks without resetting the Pomodoro.

The timer can manyally be stopped with =M-x org-timer-stop=.

A break can be started with =M-x pomodoro-break=. A pomodoro can also
manually be started without clocking in via =M-x pomodoro-start=.

#+BEGIN_SRC emacs-lisp
  (load "~/.emacs.d/org-pomodoro")
#+END_SRC
** Keyword sets

I use two workflow sets:

- One for TODOs which can either be TODO or DONE
- Another for tasks that I am WAITING for something to happen

Additionally I sometimes use the keywords PROJECT and AGENDA to denote
special bullets that I might tag (schedule/deadline) in the agenda.
These keywords give semantics to those bullets.

Note that "|" denotes a semantic state change that is reflected in a
different color. Putting the pipe at the end means that all states
prior should be shown in the same color.

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
            '((sequence "TODO" "|" "DONE")
              (sequence "PROJECT" "AGENDA" "|" "MINUTES")
              (sequence "WAITING" "|")))
#+END_SRC

** Clock Table

When using a clock table, org will by default sum up the time in
perfectly human readable terms like this:

| Headline     | Time      |
|--------------+-----------|
| *Total time* | *1d 1:03* |

For easy calculations (I don't want to parse our hours, weeks and what
not), I do prefer that the summation is done only in hours and
minutes. Therefore, I over-wrote the =org-time-clocksum-format= function:

#+BEGIN_SRC emacs-lisp
(setq org-time-clocksum-format (quote (:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t)))
#+END_SRC

This will render the same time as above as:

| Headline     | Time    |
|--------------+---------|
| *Total time* | *25:03* |

* pdf-tools

https://github.com/politza/pdf-tools

PDF Tools is, among other things, a replacement of DocView for PDF
files. The key difference is that pages are not pre-rendered by e.g.
ghostscript and stored in the file-system, but rather created
on-demand and stored in memory.

PDF Tools for me is - hands down - the best PDF viewer! It's not an
excuse to do even more within Emacs.

** Configuration

When using =evil-mode= and =pdf-tools= and looking at a zoomed PDF, it
will blink, because the cursor blinks. This configuration disables
this whilst retaining the blinking cursor in other modes.

#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'pdf-view-mode 'emacs)
(add-hook 'pdf-view-mode-hook
  (lambda ()
    (set (make-local-variable 'evil-emacs-state-cursor) (list nil))))
#+END_SRC

* Elfeed

Elfeed is an extensible web feed reader for Emacs, supporting both
Atom and RSS.

** Configuration

#+BEGIN_SRC emacs-lisp
(require 'elfeed)
(require 'elfeed-goodies)

(elfeed-goodies/setup)

;; Have automatic word-wrap
;; This should work, but there seems to be a bug
;; https://github.com/joostkremers/visual-fill-column/issues/21
;; For the time being, use =M-x visual-fill-column-mode=
;;    (add-hook 'elfeed-show-mode-hook '(lambda()
;;                                        (if (string-equal "*elfeed-entry*" (buffer-name))
;;                                            (visual-fill-column-mode))))

#+END_SRC

** Define elfeed feeds
#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/elfeed-feeds.el")
#+END_SRC
* Integration with browsers

Editing text areas in browsers can be quite tedious for the lack of a
good editor. Luckily, there's good extensions for both Chrome/Chromium
and Firefox to have a live binding to an Emacs session.

There is a good Emacs package called [[https://github.com/alpha22jp/atomic-chrome][Atomic Chrome]] which is similar to
[[https://www.emacswiki.org/emacs/Edit_with_Emacs][Edit with Emacs]], but has some advantages as below with the help of
websockets:

- The input on Emacs is reflected to the browser instantly and
  continuously.
- You can use both the browser and Emacs at the same time. They are
  updated to the same content bi-directionally.

The name "Atomic Chrome" is a bit misleading, because it actually
supports the "GhostText" protocol which allows it to be used with
Firefox, as well.

On Firefox, I'm using the [[https://github.com/GhostText/GhostText][GhostText]] addon. On Chromium, I'm using
the [[https://github.com/tuvistavie/atomic-chrome][AtomicChrome]] extension. GhostText is also available for Chrome,
but it doesn't work for me which is a non-issue, because both plugins
work just the same way: Enter a textarea, hit a button, Emacs opens
up, type the text, end the session with =C-c C-c=.

#+BEGIN_SRC emacs-lisp
  (require 'atomic-chrome)
  ;; Handle if there is an Emacs instance running which has the server already
  ;; started
  (ignore-errors
      ;; Start the server
      (atomic-chrome-start-server))
#+END_SRC

Note: I opened a [[https://github.com/alpha22jp/atomic-chrome/pull/40][PR against AtomicChrome]] which will make the
safe-guard obsolete.

* Misc Custom Improvements

Some helper functions and packages I wrote that are only accessible
within this Git repository and not published to a package repository.

** Translations

Elisp wrapper around the dict.cc translation service. Translations are
exposed in an org-mode table.

Demo: [[https://asciinema.org/a/hMTM9EDHE0cphaDRFr4JXr1iw][https://asciinema.org/a/hMTM9EDHE0cphaDRFr4JXr1iw.png]]

*** Load dict.el

#+BEGIN_SRC emacs-lisp
  (load "~/.emacs.d/dict")
#+END_SRC
** Helper functions to clean up the gazillion buffers

When switching projects in Emacs, it can be prudent to clean up every
once in a while. Deleting all buffers except the current one is one of
the things I often do (especially in the long-running =emacsclient=).

#+BEGIN_SRC emacs-lisp
  (defun kill-other-buffers ()
    "Kill all other buffers."
    (interactive)
    (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))
#+END_SRC

=dired= will create buffers for every visited folder. This is a helper
to clear them out once you're done working with those folders.

#+BEGIN_SRC emacs-lisp

  (defun kill-dired-buffers ()
    "Kill all open dired buffers."
    (interactive)
    (mapc (lambda (buffer)
            (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
              (kill-buffer buffer)))
          (buffer-list)))
#+END_SRC
** Encode HTML to HTML entities
   Rudimentary function converting certain HTML syntax to HTML entities.
#+BEGIN_SRC emacs-lisp
  (defun encode-html (start end)
    "Encodes HTML entities; works great in Visual Mode (START END)."
    (interactive "r")
    (save-excursion
      (save-restriction
        (narrow-to-region start end)
        (goto-char (point-min))
        (replace-string "&" "&amp;")
        (goto-char (point-min))
        (replace-string "<" "&lt;")
        (goto-char (point-min))
        (replace-string ">" "&gt;"))))
#+END_SRC
** Convenience functions when working with PDF exports

When working on markdown or org-mode files that will be converted to
PDF, I use =pdf-tools= to preview the PDF and shortcuts to
automatically save, compile and reload on demand.

[[https://www.youtube.com/watch?v=Pd0JwOqh-gI][Here]] is a screencast showing how I edit Markdown or org-mode files in
Emacs whilst having a PDF preview.

In a screenshot, it looks like this:

[[file:images/edit_markup_with_preview.png]]

#+BEGIN_SRC emacs-lisp
  (defun md-compile ()
    "Compiles the currently loaded markdown file using pandoc into a PDF"
    (interactive)
    (save-buffer)
    (shell-command (concat "pandoc " (buffer-file-name) " -o "
                           (replace-regexp-in-string "md" "pdf" (buffer-file-name)))))

  (defun update-other-buffer ()
    (interactive)
    (other-window 1)
    (revert-buffer nil t)
    (other-window -1))

  (defun md-compile-and-update-other-buffer ()
    "Has as a premise that it's run from a markdown-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (md-compile)
    (update-other-buffer))

  (defun latex-compile-and-update-other-buffer ()
    "Has as a premise that it's run from a latex-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (save-buffer)
    (shell-command (concat "pdflatex " (buffer-file-name)))
    (switch-to-buffer (other-buffer))
    (kill-buffer)
    (update-other-buffer))

  (defun org-compile-beamer-and-update-other-buffer ()
    "Has as a premise that it's run from an org-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (org-beamer-export-to-pdf)
    (update-other-buffer))

  (defun org-compile-latex-and-update-other-buffer ()
    "Has as a premise that it's run from an org-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (org-latex-export-to-pdf)
    (update-other-buffer))

  (eval-after-load 'latex-mode
    '(define-key latex-mode-map (kbd "C-c r") 'latex-compile-and-update-other-buffer))

  (define-key org-mode-map (kbd "C-c lr") 'org-compile-latex-and-update-other-buffer)
  (define-key org-mode-map (kbd "C-c br") 'org-compile-beamer-and-update-other-buffer)

  (eval-after-load 'markdown-mode
    '(define-key markdown-mode-map (kbd "C-c r") 'md-compile-and-update-other-buffer))
#+END_SRC
** Use left Cmd to create Umlauts

Unrelated to Emacs, in macOS, you can write Umlauts by using the combo
=M-u [KEY]=. For example =M-u u= will create the letter =ü=.

This is actually faster than the default way of Emacs or that of VIM.
The following code ports that functionality to Emacs.

Thx [[https://github.com/jcfischer][@jcfischer]] for the function!

#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map [dead-diaeresis]
    (lookup-key key-translation-map "\C-x8\""))
  (define-key isearch-mode-map [dead-diaeresis] nil)
  (global-set-key (kbd "M-u")
                  (lookup-key key-translation-map "\C-x8\""))

#+END_SRC

** Clean up messy buffers (i.e. web wikis or elfeed-show)
#+BEGIN_SRC emacs-lisp

  (defun visual-clean ()
    "Clean up messy buffers (i.e. web wikis or elfeed-show)"
    (interactive)
    (visual-line-mode)
    (visual-fill-column-mode))

#+END_SRC
** Generate passwords
   Through =pwgen=.

   Thanks to [[https://github.com/branch14/emacs.d][@branch14]] of 200ok fame for the function!
#+BEGIN_SRC emacs-lisp

(defun generate-password ()
  "Generates and inserts a new password"
  (interactive)
  (insert
   (shell-command-to-string
    (concat "pwgen -A " (read-string "Length: " "16") " 1"))))

#+END_SRC
** Open passwords file
   #+BEGIN_SRC emacs-lisp
     (defun passwords ()
       "Open main 'passwords' file."
       (interactive)
       (find-file (concat org-directory "vault/primary.org.gpg")))
   #+END_SRC
** Running =M-x shell= with =zsh=
   If you're a =zsh= user, you might have configured a custom prompt
   and such. Also, you might be using a powerful =$TERM= for that.
   When running =zsh= within =M-x shell=, you will have to set the
   =$TERM= to =dumb=, though. Otherwise you'll get all kinds of escape
   sequences instead of colored text.

I'm using this within my =~/.zshrc=

#+BEGIN_SRC shell
# This allows running `shell` properly within Emacs
if [ -n "$INSIDE_EMACS" ]; then
  export TERM=dumb
else
  export TERM=xterm-256color
fi
#+END_SRC

** =server-shutdown=
This is the converse function to the built-in =server-start=.
#+BEGIN_SRC emacs-lisp
(defun server-shutdown ()
  "Save buffers, Quit, and Shutdown (kill) server"
  (interactive)
  (save-some-buffers)
  (kill-emacs))
#+END_SRC
* Mail

Writing and reading mail is inherently a text-based workflow. Yes,
there's HTML mails and attachments, but at the core Email is probably
/the place/ where many people write and consume the most text. To
utilize the best text-processing program available, makes a lot of
sense.

When combined with other powerful features of Emacs (such as org-mode
for organizing mails into projects and todos), processing mails within
Emacs not only makes a lot of sense, but becomes a powerhouse.

** mu4e

Emacs has many options for MTAs. I'm using [[http://www.djcbsoftware.nl/code/mu/mu4e/][MU4E]] which is a little
similar to using [[http://www.mutt.org/][mutt]] with [[https://notmuchmail.org/][notmuch]]. As SMTP, I'm using the built-in
=smtpmail= Emacs package.

*** Installation

*** General

-  Configure =.offlineimaprc= file for IMAP
-  Configure =.authinfo= file for SMTP
-  https://www.emacswiki.org/emacs/GnusAuthinfo


**** Authentication
Tell Emacs where to find the encrypted =.authinfo= file.

#+BEGIN_SRC
(setq auth-sources
    '((:source "~/.authinfo.gpg")))
#+END_SRC

**** PDFs

To open PDFs within Mu4e with Emacs, then there's one thing to
configure. Mu4e uses =xdg-open= to chose the app to open any mime type.

Configure =xdg-open= to use Emacs in =.local/share/applications/mimeapps.list=:

#+BEGIN_EXAMPLE
    xdg-mime default emacs.desktop application/pdf
#+END_EXAMPLE

**** Installation

MU works on a local Maildir folder. For synchronization
[[http://www.offlineimap.org/][offlineimap]] is used. Install:

- Debian: =apt-get install offlineimap=
- macOS: =brew install offlineimap=

For MU4E to work, install MU and MU4E:

- Debian: =apt-get install mu4e=
- macOS: =brew install mu --with-emacs=

For starttls to work when sending mail, install gnutls:

- Debian: =apt-get install gnutls-bin=
- macOS: =brew install gnutls=

** Configuration

Accounts setup

#+BEGIN_SRC emacs-lisp

  (require 'mu4e)

  (require 'org-mu4e)

  (setq send-mail-function 'smtpmail-send-it)

  ;; Default account on startup
  (setq user-full-name  "Alain M. Lafon"
        mu4e-sent-folder "/200ok/INBOX.Sent"
        mu4e-drafts-folder "/200ok/INBOX.Drafts"
        mu4e-trash-folder "/200ok/INBOX.Trash")

  (setq smtpmail-debug-info t
        message-kill-buffer-on-exit t
        ;; Custom script to run offlineimap in parallel for multiple
        ;; accounts as discussed here:
        ;; http://www.offlineimap.org/configuration/2016/01/29/why-i-m-not-using-maxconnctions.html
        ;; This halves the time for checking mails for 4 accounts for me
        ;; (when nothing has to be synched anyway)
        mu4e-get-mail-command "offlineimap_parallel.sh"
        mu4e-attachment-dir "~/switchdrive/org/files/inbox")

  (setq mu4e-maildir "~/Maildir/")

  ;; show full addresses in view message (instead of just names)
  ;; toggle per name with M-RET
  (setq mu4e-view-show-addresses t)

  ;; Alternatives are the following, however in first tests they
  ;; show inferior results
  ;; (setq mu4e-html2text-command "textutil -stdin -format html -convert txt -stdout")
  ;; (setq mu4e-html2text-command "html2text -utf8 -width 72")
  ;; (setq mu4e-html2text-command "w3m -dump -T text/html")

  (defvar my-mu4e-account-alist
    '(("200ok"
       (user-full-name  "Alain M. Lafon")
       (mu4e-compose-signature "200ok GmbH\nGeschäftsführer\n\nalain@200ok.ch\n+41 76 405 05 67\nhttps://200ok.ch/\n\nCheck out our newest incubator: https://quickshift.ch/")
       (mu4e-compose-signature-auto-include t)
       (mu4e-sent-folder "/200ok/INBOX.Sent")
       (mu4e-drafts-folder "/200ok/INBOX.Drafts")
       (mu4e-trash-folder "/200ok/INBOX.Trash")
       (user-mail-address "alain@200ok.ch")
       (smtpmail-default-smtp-server "smtp.mailgun.org")
       (smtpmail-local-domain "200ok.ch")
       (smtpmail-smtp-user "alain@200ok.ch")
       (smtpmail-smtp-server "smtp.mailgun.org")
       (smtpmail-stream-type starttls)
       (smtpmail-smtp-service 25))
      ("zhaw"
       (mu4e-compose-signature-auto-include nil)
       (user-full-name  "Alain M. Lafon")
       (mu4e-sent-folder "/zhaw/Sent Items")
       (mu4e-drafts-folder "/zhaw/Drafts")
       (mu4e-trash-folder "/zhaw/Deleted Items")
       (user-mail-address "lafo@zhaw.ch")
       (smtpmail-default-smtp-server "smtps.zhaw.ch")
       (smtpmail-smtp-server "smtps.zhaw.ch")
       (smtpmail-local-domain "zhaw.ch")
       (smtpmail-smtp-user "lafo@zhaw.ch")
       (smtpmail-stream-type starttls)
       (smtpmail-smtp-service 587))
      ("zen-tempel"
       (user-full-name  "Zen Mönch Alain M. Lafon")
       (mu4e-compose-signature "Insopor Zen Akademie\nZen Mönch\n\nalain@zen-tempel.ch\n+41 76 405 05 67\n\nhttps://zen-temple.net/")
       (mu4e-compose-signature-auto-include t)
       (mu4e-sent-folder "/zen-tempel/INBOX.Sent")
       (mu4e-drafts-folder "/zen-tempel/INBOX.Drafts")
       (mu4e-trash-folder "/zen-tempel/INBOX.Trash")
       (user-mail-address "alain@zen-tempel.ch")
       (smtpmail-default-smtp-server "mail.your-server.de")
       (smtpmail-local-domain "zen-tempel.ch")
       (smtpmail-smtp-user "alain@zen-tempel.ch")
       (smtpmail-smtp-server "mail.your-server.de")
       (smtpmail-stream-type starttls)
       (smtpmail-smtp-service 25))
      ("dispatched"
       (user-full-name  "Alain M. Lafon")
       (mu4e-compose-signature-auto-include nil)
       (mu4e-sent-folder "/dispatched/INBOX.Sent")
       (mu4e-drafts-folder "/dispatched/INBOX.Drafts")
       (mu4e-trash-folder "/dispatched/INBOX.Trash")
       (user-mail-address "alain.lafon@dispatched.ch")
       (smtpmail-default-smtp-server "mail.your-server.de")
       (smtpmail-local-domain "dispatched.ch")
       (smtpmail-smtp-user "munen@dispatched.ch")
       (smtpmail-smtp-server "mail.your-server.de")
       (smtpmail-stream-type starttls)
       (smtpmail-smtp-service 25))))

  ;; Whenever a new mail is to be composed, change all relevant
  ;; configuration variables to the respective account. This method is
  ;; taken from the MU4E documentation:
  ;; http://www.djcbsoftware.nl/code/mu/mu4e/Multiple-accounts.html#Multiple-accounts
  (defun my-mu4e-set-account ()
    "Set the account for composing a message."
    (let* ((account
            (if mu4e-compose-parent-message
                (let ((maildir (mu4e-message-field mu4e-compose-parent-message :maildir)))
                  (string-match "/\\(.*?\\)/" maildir)
                  (match-string 1 maildir))
              (completing-read (format "Compose with account: (%s) "
                                       (mapconcat #'(lambda (var) (car var))
                                                  my-mu4e-account-alist "/"))
                               (mapcar #'(lambda (var) (car var)) my-mu4e-account-alist)
                               nil t nil nil (caar my-mu4e-account-alist))))
           (account-vars (cdr (assoc account my-mu4e-account-alist))))
      (if account-vars
          (mapc #'(lambda (var)
                    (set (car var) (cadr var)))
                account-vars)
        (error "No email account found"))))


  (add-hook 'mu4e-compose-pre-hook 'my-mu4e-set-account)
  (add-hook 'mu4e-compose-mode-hook 'flyspell-mode)
  (add-hook 'mu4e-compose-mode-hook (lambda ()
                                     (ispell-change-dictionary "deutsch")))


  (setq mu4e-refile-folder
        (lambda (msg)
          (cond
           ((string-match "^/dispatched.*"
                          (mu4e-message-field msg :maildir))
            "/dispatched/INBOX.Archive")
           ((string-match "^/zen-tempel.*"
                          (mu4e-message-field msg :maildir))
            "/zen-tempel/INBOX.Archive")
           ((string-match "^/200ok.*"
                          (mu4e-message-field msg :maildir))
            "/200ok/INBOX.Archive")
           ((string-match "^/zhaw.*"
                          (mu4e-message-field msg :maildir))
            "/zhaw/Archive")
           ;; everything else goes to /archive
           (t  "/archive"))))


  ;; Empty the initial bookmark list
  (setq mu4e-bookmarks '())

  ;; Re-define all standard bookmarks to not include the spam folders
  ;; for searches
  (defvar d-spam "NOT (maildir:/dispatched/INBOX.spambucket OR maildir:/zen-tempel/INBOX.spambucket OR maildir:/200ok/INBOX.spambucket OR maildir:/zhaw/\"Junk E-Mail\" OR maildir:/zhaw/\"Deleted Items\")")

  (defvar inbox-folders (string-join '("maildir:/dispatched/INBOX"
                                       "maildir:/zhaw/INBOX"
                                       "maildir:/zen-tempel/INBOX"
                                       "maildir:/200ok/INBOX")
                                     " OR "))

  (defvar draft-folders (string-join '("maildir:/dispatched/INBOX.Drafts"
                                       "maildir:/zhaw/INBOX.Drafts"
                                       "maildir:/zen-tempel/INBOX.Drafts"
                                       "maildir:/200ok/INBOX.Drafts")
                                     " OR "))

  (defvar spam-folders (string-join '("maildir:/dispatched/INBOX.spambucket"
                                       "maildir:/zhaw/INBOX.spambucket"
                                       "maildir:/zen-tempel/INBOX.spambucket"
                                       "maildir:/200ok/INBOX.spambucket")
                                    " OR "))

  (add-to-list 'mu4e-bookmarks
               '((concat d-spam " AND date:today..now")                  "Today's messages"     ?t))
  (add-to-list 'mu4e-bookmarks
               '((concat d-spam " AND date:7d..now")                     "Last 7 days"          ?w))
  (add-to-list 'mu4e-bookmarks
               '((concat d-spam " AND mime:image/*")                     "Messages with images" ?p))
  (add-to-list 'mu4e-bookmarks
               '(spam-folders "All spambuckets"     ?S))
  (add-to-list 'mu4e-bookmarks
               '(draft-folders "All drafts"     ?d))
  (add-to-list 'mu4e-bookmarks
               '(inbox-folders "All inbox mails"     ?i))
  (add-to-list 'mu4e-bookmarks
               '((concat d-spam " AND (flag:unread OR flag:flagged) AND NOT flag:trashed")
                 "Unread messages"      ?u))


#+END_SRC

Check for supposed attachments prior to sending them

#+BEGIN_SRC emacs-lisp
(defvar my-message-attachment-regexp "\\([Ww]e send\\|[Ii] send\\|attach\\|angehängt\\|[aA]nhang\\|angehaengt\\|haenge\\|hänge\\)")
(defun my-message-check-attachment nil
  "Check if there is an attachment in the message if I claim it."
  (save-excursion
    (message-goto-body)
    (when (search-forward-regexp my-message-attachment-regexp nil t nil)
      (message-goto-body)
      (unless (or (search-forward "<#part" nil t nil)
                  (message-y-or-n-p
                   "No attachment. Send the message ?" nil nil))
        (error "No message sent")))))
(add-hook 'message-send-hook 'my-message-check-attachment)
#+END_SRC

For mail completion, only consider emails that have been seen in the
last 6 months. This gets rid of legacy mail addresses of people.

#+BEGIN_SRC emacs-lisp
  (setq mu4e-compose-complete-only-after (format-time-string
                                          "%Y-%m-%d"
                                          (time-subtract (current-time) (days-to-time 150))))


#+END_SRC

HTML Mails

#+BEGIN_SRC emacs-lisp
(require 'mu4e-contrib)
(setq mu4e-html2text-command 'mu4e-shr2text)
(add-to-list 'mu4e-view-actions '("ViewInBrowser" . mu4e-action-view-in-browser) t)

#+END_SRC

Setting =Format=Flowed= for non-text-based mail clients which don't
respect actual formatting, but let the text "flow" as they please.

#+BEGIN_SRC emacs-lisp
(setq mu4e-compose-format-flowed t)
#+END_SRC

Updating mails:

  - Periodic - every 15 minutes
  - Happening in the background

Note: There's no notifications, because that's only distracting.

#+BEGIN_SRC emacs-lisp
(setq mu4e-update-interval (* 15 60))
(setq mu4e-index-update-in-background t)
#+END_SRC

GPG configuration:

- =C-c C-e s= to sign
- =C-c C-e e= to encrypt
- =C-c C-e v= to verify the signature
- =C-c C-e d= to decrypt

#+BEGIN_SRC emacs-lisp

(add-hook 'mu4e-compose-mode-hook 'epa-mail-mode)
(add-hook 'mu4e-view-mode-hook 'epa-mail-mode)

#+END_SRC

Automatic line breaks when reading mail

#+BEGIN_SRC emacs-lisp
(add-hook 'mu4e-view-mode-hook 'visual-line-mode)
#+END_SRC

Do not reply to self

#+BEGIN_SRC emacs-lisp
  (setq mu4e-compose-dont-reply-to-self t)

  (add-to-list 'mu4e-user-mail-address-list "alain@200ok.ch")
  (add-to-list 'mu4e-user-mail-address-list "alain.lafon@dispatched.ch")
  (add-to-list 'mu4e-user-mail-address-list "lafo@zhaw.ch")
#+END_SRC

*** TODO Use Quoted printable text for outgoing messages to enable automatic line breaks
**** If this is successfull, send upstream PR to MU4E
https://mathiasbynens.be/notes/gmail-plain-text
https://mothereff.in/quoted-printable
https://www.gnu.org/software/emacs/manual/html_node/emacs-mime/qp.html

** Mail filtering
   Add a header action "Block" which add the Senders Name and From
   Address to a procmail blacklist.
#+BEGIN_SRC emacs-lisp
  (defun append-line-to-file (line path)
    "Append a `line` to a file behind `path`"
    (write-region (concat line "\n") nil path 'append))

  (defun mu4e-blacklist-from (msg)
    "Add the `from` of a message to the procmail blacklist"
    (let* ((from (mu4e-message-field msg :from))
           (from_name (car (car from)))
           (from_address (cdr (car from))))
      ;; Block the senders Name
      (if from_name
          (append-line-to-file from_name "~/.procmail/blacklist_from.txt"))
      ;; Block the Email-Address
      (append-line-to-file from_address "~/.procmail/blacklist_from.txt")

      (message "Blocking: %s" from)))

  (defun mu4e-blacklist-subject (msg)
    "Add the `subject` of a message to the procmail blacklist"
    (let* ((subject (mu4e-message-field msg :subject)))
      (if subject
          (append-line-to-file subject "~/.procmail/blacklist_subject.txt"))

      (message "Blocking: %s" subject)))

  (add-to-list 'mu4e-headers-actions
    '("F Block 'From:'" . mu4e-blacklist-from) t)

  (add-to-list 'mu4e-headers-actions
    '("S Block 'Subject:'" . mu4e-blacklist-subject) t)

#+END_SRC
* Ivy/Counsel/Swiper

https://github.com/abo-abo/swiper

*Ivy*, a generic completion mechanism for Emacs.

*Counsel*, a collection of Ivy-enhanced versions of common Emacs commands.

*Swiper*, an Ivy-enhanced alternative to isearch.

=Ivy= is an interactive interface for completion in Emacs. Emacs uses
completion mechanism in a variety of contexts: code, menus, commands,
variables, functions, etc. Completion entails listing, sorting,
filtering, previewing, and applying actions on selected items. When
active, =ivy-mode= completes the selection process by narrowing
available choices while previewing in the minibuffer. Selecting the
final candidate is either through simple keyboard character inputs or
through powerful regular expressions.

** Configuration

#+BEGIN_SRC emacs-lisp
    (ivy-mode 1)
    (setq enable-recursive-minibuffers t)
    (global-set-key (kbd "<f6>") 'ivy-resume)
#+END_SRC

Show total amount of matches and the index of the current match

#+BEGIN_SRC emacs-lisp
(setq ivy-count-format "(%d/%d) ")
#+END_SRC

Wrap to the first result when on the last result and vice versa.

#+BEGIN_SRC emacs-lisp
(setq ivy-wrap t)
#+END_SRC

Enable =Swiper=

#+BEGIN_SRC emacs-lisp
    (global-set-key "\C-s" 'swiper)
#+END_SRC

Configure =Counsel=

#+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-x C-f") 'counsel-find-file)
    (global-set-key (kbd "<f1> f") 'counsel-describe-function)
    (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
    (global-set-key (kbd "<f1> l") 'counsel-find-library)
    (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
    (global-set-key (kbd "C-c k") 'counsel-ag)
    (global-set-key (kbd "C-x l") 'counsel-locate)
    (define-key minibuffer-local-map (kbd "C-r") 'counsel-minibuffer-history)
#+END_SRC

Before I used =smex= which is M-x combined with ido. Counsel makes this even nicer.

#+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "M-x") 'counsel-M-x)
#+END_SRC

*** Disable Ivy where it is broken

Ivy cannot search in PDFs. It tries to search in the PDF source code.
Therefore I fall back to using isearch within PDFs.

#+BEGIN_SRC emacs-lisp
  (add-hook 'pdf-view-mode-hook '(lambda()
                                   (define-key pdf-view-mode-map "\C-s" 'isearch-forward)))
#+END_SRC

*** Improve other packages with ivy

  Projectile completion (Default is =ido=)

#+BEGIN_SRC emacs-lisp
  (setq projectile-completion-system 'ivy-completing-read)
#+END_SRC

  Mu4e "folder" and "from" completion (Default is =ido=)

#+BEGIN_SRC emacs-lisp
  (setq mu4e-completing-read-function 'ivy-completing-read)
#+END_SRC

  Synosaurus completion (Default is =ido=)

#+BEGIN_SRC emacs-lisp
  (setq synosaurus-choose-method 'ivy-read)
#+END_SRC

** Notes on =Ivy= vs =ido=

I used to use =ido= amd =smex= instead of the Ivy/Counsel/Swiper
suite. It worked well, but Ivy is a little more powerful. I'm leaving
some notes on =ido= here for future reference and in case that the Ivy
suite goes out of favor in the community.

=ido= means "Interactively Do Things"

=ido= has a completion engine that's sensible to use everywhere. It is
built-in and nice and could change a lot of defaults like =find-file=
and switching buffers.

#+BEGIN_SRC emacs-lisp
  ;;(ido-mode t)
  ;;(ido-everywhere t)
  ;;(setq ido-enable-flex-matching t)
#+END_SRC

* Powerline

https://github.com/milkypostman/powerline

Emacs version of the Vim powerline.

#+BEGIN_SRC emacs-lisp
(require 'powerline)
(powerline-center-evil-theme)
#+END_SRC

* Write Quality

** =writegood-mode=
https://github.com/bnbeckwith/writegood-mode

This is a minor mode to aid in finding common writing problems.

It highlights text based on a set of weasel-words, passive-voice and
duplicate words.

** Theraurus
https://github.com/hpdeifel/synosaurus/

Synosaurus is a thesaurus front-end with pluggable back-end.

Use the [[http://openthesaurus.de/][openthesaurus.de]] back-end.

#+BEGIN_SRC emacs-lisp
  (setq synosaurus-backend 'synosaurus-backend-openthesaurus)
#+END_SRC

** Flyspell

Flyspell is a built-in minor mode for on-the-fly spell checking.

Flyspell uses ispell or aspell in the background. I'm using the
default (ispell) and have installed a German dictionary from [[http://fmg-www.cs.ucla.edu/geoff/ispell-dictionaries.html#German-dicts][here]].

*** Configuration

Order corrections by likeliness, not by the default of alphabetical
ordering.

#+BEGIN_SRC emacs-lisp
(setq flyspell-sort-corrections nil)
#+END_SRC

Do not print messages for every word (when checking the entire
buffer). This is a major performance gain.
#+BEGIN_SRC emacs-lisp
(setq flyspell-issue-message-flag nil)
#+END_SRC

Switch between German and English dictionaries.

#+BEGIN_SRC emacs-lisp
  (defun flyspell-switch-dictionary()
    "Switch between German and English dictionaries"
    (interactive)
    (let* ((dic ispell-current-dictionary)
           (change (if (string= dic "deutsch") "english" "deutsch")))
      (ispell-change-dictionary change)
      (message "Dictionary switched from %s to %s" dic change)))
#+END_SRC

*** Do not loose all spellchecking information after adding one word to a personal dictionary

Advice to re-check the buffer after a word has been added to the
dictionary. This has the benefit of the word actually being cleared,
but the downside that the whole buffer has to be re-checked which an
take some time.

#+BEGIN_SRC emacs-lisp

(defun flyspell-buffer-after-pdict-save (&rest _)
  (flyspell-buffer))

(advice-add 'ispell-pdict-save :after #'flyspell-buffer-after-pdict-save)

#+END_SRC

The proper solution (for which I don't have time now) is to just mark
all further occurrences of the word you just saved as correct (without
having to recheck the whole buffer).

*** TODO Implement =ispell-pdict-save= with above requirement

* OS Specific
** Linux

"Fira Code Retina" as default font. Get it via the =fonts-firacode=
Debian package.

#+BEGIN_SRC emacs-lisp

  (when (eq system-type 'gnu/linux)
    (set-frame-font "Fira Code Retina 15")
    ;; Default Browser
    (setq browse-url-browser-function 'browse-url-generic
          browse-url-generic-program "chromium")
    (menu-bar-mode -1)
    ;; enable pdf-tools
    (pdf-tools-install))

#+END_SRC

** macOS

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (set-frame-font "Menlo 14")
  ; Use Spotlight to search with M-x locate
  (setq locate-command "mdfind"))

(defun whack-whitespace-forward ()
  "Delete all white space from point to the next word."
  (interactive nil)
  (re-search-forward "[ \t\n]+" nil t)
  (replace-match "" nil nil))

(defun un-indent-by-removing-4-spaces ()
  "remove 4 spaces from beginning of a line"
  (interactive)
  (save-excursion
    (save-match-data
      (beginning-of-line)
      ;; get rid of tabs at beginning of line
      (when (looking-at "^\\s-+")
        (untabify (match-beginning 0) (match-end 0)))
      (when (looking-at "^    ")
        (replace-match "")))))

(global-set-key (kbd "C-M-+") 'default-text-scale-increase)
(global-set-key (kbd "C-M--") 'default-text-scale-decrease)
(global-set-key (kbd "M-[") 'whack-whitespace-forward)
(global-set-key (kbd "<backtab>") 'un-indent-by-removing-4-spaces)

(when (eq system-type 'darwin) ;; mac specific settings
  (setq mac-option-modifier 'alt)
  (setq mac-command-modifier 'meta)
  (global-set-key [kp-delete] 'delete-char)) ;; sets fn-delete to be right-delete

#+END_SRC

* Bad experience

The following packages would be nice, in theory. In practice something
is yet amiss, but it might be different in the future. That's why I'm
keeping them around and will try them at another time.

** clipmon
https://github.com/bburns/clipmon

Proposition: Monitors system clipboard and puts everything in the kill-ring.

Caveat: In theory, I liked the package. However, it seemed to cause
racing conditions and crashed Emacs multiple times a day. When this is
re-implemented in a non-blocking mode, this would be nice.

#+BEGIN_SRC emacs-lisp
  ;; (add-to-list 'after-init-hook 'clipmon-mode-start)
#+END_SRC

*** Comment

Theoretically this is really nice to have functionality. However, I
couldn't run it for long. Emacs started freezing a lot on the day when
I added this lib. I assume, because clipmon is blocking - and I always
run multiple instances of Emacs in parallel. They might be in for a
classic racing condition. Might be just another bug.

** =parinfer-mode=

Proposition: When working with Lisp, there's the option of handing parentheses
manually or let them be dealt with by the magic that is [[http://shaunlebron.github.io/parinfer/][Parinfer]]. I'm
using the wonderful [[https://github.com/DogLooksGood/parinfer-mode][parinfer-mode]].

Caveat: The original Parinfer curiously is written in JavaScript.
=parinfer-mode= is a re-implementation in Elisp. When I tried it, it
was still in it's early stages and quite buggy. However, the original
Parinfer algorithm is quite nice. I'll try again at some point.

#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'clojure-mode-hook #'parinfer-mode)
  ;; (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)
  ;; (setq parinfer-extensions '(company pretty-parens evil))
  ;; (eval-after-load "parinfer"
  ;;   '(progn
  ;;      (define-key parinfer-mode-map (kbd "C-,") 'parinfer-toggle-mode)
  ;;      (define-key parinfer-region-mode-map (kbd ">") 'parinfer-shift-right)
  ;;      (define-key parinfer-region-mode-map (kbd "<") 'parinfer-shift-left)))

;; https://github.com/DogLooksGood/parinfer-mode
(use-package parinfer
  :ensure t
  :bind
  (("C-," . parinfer-toggle-mode))
  :init
  (progn
    (setq parinfer-extensions
          '(defaults       ; should be included.
             pretty-parens  ; different paren styles for different modes.
             evil           ; If you use Evil.
             ;;lispy          ; If you use Lispy. With this extension, you should install Lispy and do not enable lispy-mode directly.
             paredit        ; Introduce some paredit commands.
             smart-tab      ; C-b & C-f jump positions and smart shift with tab & S-tab.
             smart-yank))   ; Yank behavior depend on mode.
    (add-hook 'clojure-mode-hook #'parinfer-mode)
    (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)
    (add-hook 'common-lisp-mode-hook #'parinfer-mode)
    (add-hook 'scheme-mode-hook #'parinfer-mode)
    (add-hook 'lisp-mode-hook #'parinfer-mode)))

#+END_SRC

* Presentation / Beamer
** Set safe themes (to execute LISP code)

#+BEGIN_SRC emacs-lisp
  (setq custom-safe-themes
     (quote
      ("df3e05e16180d77732ceab47a43f2fcdb099714c1c47e91e8089d2fcf5882ea3"
       "d09467d742f713443c7699a546c0300db1a75fed347e09e3f178ab2f3aa2c617"
       "8db4b03b9ae654d4a57804286eb3e332725c84d7cdab38463cb6b97d5762ad26"
       "85c59044bd46f4a0deedc8315ffe23aa46d2a967a81750360fb8600b53519b8a"
       default)))
#+END_SRC
** Configure default theme and font size
#+BEGIN_SRC emacs-lisp
  (defun standard-mode ()
    "Default theme and font size.  Pendant: (presentation-mode)."
    (interactive)

    (set-face-attribute 'default nil :height 150)
    ;; Themes
    ;; (set-frame-parameter nil 'background-mode 'dark)
    ;; Dark, High Contrast
    (load-theme 'wombat)
    (setq frame-background-mode (quote dark))
    ;; Dark, Low contrast
    ;; (load-theme 'darktooth)
    ;; Dark, Lowest contrast
    ;; (load-theme 'zenburn)
     )

#+END_SRC

** Configure presentation theme and font size

#+BEGIN_SRC emacs-lisp
  (defun presentation-mode ()
    "Presentation friendly theme and font size.  Pendant: (standard-mode)."
    (interactive)
    (load-theme 'leuven t)
    (set-face-attribute 'default nil :height 140))
#+END_SRC

** Enable default theme and font

#+BEGIN_SRC emacs-lisp
  (standard-mode)
#+END_SRC
* Org Mode Time Export Table

Create a customized time table ready for CSV export.

Usage:

#+BEGIN_SRC org

#+name: ok-timetable
,#+BEGIN_SRC elisp
(ok-export-org-timetable "2018-05-09")
,#+END_SRC

#+END_SRC


When evaluating the src-block above, it'll yield a table like:

#+BEGIN_SRC org

,#+RESULTS: ok-timetable
|       date |  hours | task                             |
|------------+--------+----------------------------------|
| 2018-05-09 |   0:02 | #support                         |
| 2018-05-09 |   0:17 | #support                         |
|------------+--------+----------------------------------|
|            | total: | :=vsum(@2..@-1);T                |

#+END_SRC


#+BEGIN_SRC emacs-lisp
  (require 'seq)

  (defun ok-filter-table-by-date (tbl from-date table-row)
    "Filter a TBL by FROM-DATE which is found in TABLE-ROW."
    ;; Sort by date
    (seq-sort '(lambda (e1 e2)
                 (string-lessp (nth table-row e1)
                               (nth table-row e2)))
              ;; Filter to start with FROM-DATE
              (seq-filter (lambda (elem)
                            (let ((date-elem (nth table-row elem)))
                              ;; >=
                              (when (or (string-greaterp date-elem from-date)
                                        (string-equal date-elem from-date))
                                elem)))
                          tbl)))

  (defun ok-generate-clock-table ()
    "Generate a list of org elements of type 'clock."
    (let* ((ast (org-element-parse-buffer 'element)))
      ;; Map a function to all elements of TYPE 'clock which extracts
      ;; the TITLE, DURATION and DATE of a TODO.
      (org-element-map ast 'clock
        (lambda (clock-elem)
          (let* ((val (org-element-property :value clock-elem))
                 (task (org-element-property :parent (org-element-property :parent clock-elem))))
            `(,(let ((year (org-element-property :year-start val))
                     (month (org-element-property :month-start val))
                     (day (org-element-property :day-start val)))
                 (format "%4d-%02d-%02d" year month day ))
              ,(org-element-property :duration clock-elem)
              ,(org-element-property :title task)))))))

  (defun ok-export-org-timetable (from-date)
    "Generate a list from 'org-mode' clock elements starting from FROM-DATE."
    ;; Concatenate header, element data and footer into one list which
    ;; will automatically be rendered by org-mode as a table.
    (nconc
     '(("date" "hours" "task"))
     '(hline)
     ;; Generate tree of all visible elements within buffer (narrowing
     ;; works).
     (ok-filter-table-by-date (ok-generate-clock-table) from-date 0)
     '(hline)
     '(("" "total:" ":=vsum(@2..@-1);T"))))
#+END_SRC
